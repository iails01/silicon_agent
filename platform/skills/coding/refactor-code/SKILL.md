---
name: refactor-code
display_name: "代码重构"
description: 安全重构代码，改善结构和可维护性，保证功能不变
layer: L2
metadata:
  emoji: "♻️"
  tags: ["coding", "refactor", "maintenance"]
  applicable_roles: ["coding"]
---

# 代码重构

安全地重构代码，改善代码结构、消除技术债务、提升可维护性，同时保证功能行为不变。

## 输入

用户会提供：
- `target`：需要重构的代码文件或模块
- `goal`：重构目标（如：消除重复、拆分大函数、改善命名等）
- `constraints`（可选）：不能改变的公共接口或行为

## 工作流

### Step 1：代码分析

使用 `read` 和 `search-codebase` 全面了解重构目标：
- 当前代码结构和职责
- 调用方（谁依赖这段代码）
- 测试覆盖情况（是否有现有测试保护）
- 代码异味识别（重复、过长函数、过深嵌套等）

### Step 2：重构方案

设计重构策略（选择最小改动原则）：
- 提取方法（Extract Method）：拆分过长函数
- 内联变量/函数（Inline）：消除不必要的间接层
- 重命名（Rename）：改善命名表达意图
- 移动（Move）：调整代码位置到更合适的模块
- 替换条件（Replace Conditional）：用多态/策略模式替换复杂条件

### Step 3：逐步重构

按以下顺序执行：
1. 先做安全的重命名和移动
2. 再做结构性变更（提取/内联）
3. 最后做设计模式层面的改进
4. 每一步都保证代码可运行

### Step 4：验证

确保重构后：
- 公共 API 签名不变（除非明确要求）
- import 路径已全部更新
- 现有测试仍然通过
- 没有引入循环依赖

## 输出格式

```markdown
## 重构报告

### 重构目标
{描述}

### 代码异味
| # | 类型 | 位置 | 严重度 |
|---|------|------|--------|
| 1 | {类型} | `{file}:{line}` | {H/M/L} |

### 重构操作
| # | 操作 | 文件 | 描述 |
|---|------|------|------|
| 1 | {Extract Method} | `{file}` | {描述} |

### 变更摘要
- 修改文件：{n} 个
- 新增文件：{n} 个
- 删除文件：{n} 个
- 净代码行变化：{±n}

### 验证结果
- [ ] 公共 API 兼容
- [ ] 测试通过
- [ ] 无循环依赖
```

---
name: unit-test
display_name: "单元测试"
description: 为指定模块或函数生成单元测试，覆盖正常路径和边界条件
layer: L1
metadata:
  emoji: "🧪"
  tags: ["test", "unit-test", "testing"]
  applicable_roles: ["test"]
---

# 单元测试生成

为指定的模块、类或函数生成单元测试，覆盖正常路径、边界条件和异常场景。

## 输入

用户会提供：
- `target`：要测试的模块、类或函数
- `source_code`（可选）：源代码内容
- `test_framework`（可选）：测试框架（默认 pytest）

## 工作流

### Step 1：分析测试目标

使用 `search-codebase` skill 和 `read` 工具获取源代码，分析：
- 函数签名和参数类型
- 返回值类型和可能的返回情况
- 外部依赖（需要 mock 的部分）
- 副作用（数据库操作、文件 IO、网络调用等）

### Step 2：设计测试用例

为每个函数/方法设计测试用例：
- **正常路径**：标准输入的期望输出
- **边界条件**：空值、零值、最大值、空列表等
- **异常路径**：无效输入、权限不足、依赖失败等
- **状态变更**：验证副作用是否正确执行

### Step 3：生成测试代码

按测试用例生成测试代码：
- 使用 `pytest` 风格的测试函数
- 使用 `unittest.mock` 或 `pytest-mock` 进行依赖隔离
- 测试函数命名：`test_{function}_{scenario}_{expected_result}`
- 合理使用 fixture 减少重复

### Step 4：质量检查

确保测试代码：
- 每个测试只验证一个行为
- 测试之间相互独立
- Mock 使用合理（不过度 mock）
- 断言明确（使用具体的 assert 而非通用的 assertTrue）

## 输出格式

使用 `write` 工具将测试代码写入工作目录，同时输出摘要：

```markdown
## 单元测试报告

### 测试目标
{模块/类/函数名称}

### 测试用例
| # | 测试函数 | 场景 | 类型 |
|---|---------|------|------|
| 1 | test_xxx_normal | 正常输入 | 正常路径 |
| 2 | test_xxx_empty_input | 空输入 | 边界条件 |
| 3 | test_xxx_invalid_type | 类型错误 | 异常路径 |

### 覆盖分析
- 语句覆盖：预估 {n}%
- 分支覆盖：预估 {n}%
- 未覆盖场景：{说明}

### 生成文件
- `{test_file_path}`
```

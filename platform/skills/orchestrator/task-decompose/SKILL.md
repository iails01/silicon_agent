---
name: task-decompose
display_name: "任务分解"
description: 将复杂需求分解为可并行执行的子任务，确定依赖关系和执行顺序
layer: L1
metadata:
  emoji: "🧩"
  tags: ["orchestrator", "decompose", "planning"]
  applicable_roles: ["orchestrator"]
---

# 任务分解与编排

将复杂需求分解为可并行/串行执行的子任务，识别依赖关系，规划最优执行路径。

## 输入

用户会提供：
- `requirement`：需求描述
- `project_context`（可选）：项目上下文信息（技术栈、现有架构等）
- `constraints`（可选）：时间/资源/技术约束

## 工作流

### Step 1：需求拆解

分析需求的组成部分：
- 独立的功能模块
- 模块间的数据依赖
- 共享资源和互斥条件
- 可复用的现有组件

### Step 2：依赖图构建

为每个子任务建立依赖关系：
- 前置条件（必须先完成的任务）
- 可并行执行的任务组
- 关键路径识别（最长依赖链）

### Step 3：阶段分配

将子任务映射到执行阶段：
- 相同 `order` 值的阶段可并行执行
- 有依赖关系的阶段必须串行
- 为每个阶段选择最适合的 agent role
- 估算每个阶段的复杂度（S/M/L）

### Step 4：风险标注

识别可能的失败点：
- 技术风险（新技术、复杂集成）
- 依赖风险（外部服务、第三方 API）
- 需要人工审批的节点（Gate 设置）

### Step 5：执行计划生成

生成可直接执行的任务编排方案。

## 输出格式

```markdown
## 任务分解报告

### 需求概要
{一句话概括}

### 子任务清单

| # | 任务名 | Agent | Order | 依赖 | 复杂度 | 说明 |
|---|--------|-------|-------|------|--------|------|
| 1 | {名称} | spec | 1 | 无 | S | {描述} |
| 2 | {名称} | coding | 2 | #1 | M | {描述} |
| 3 | {名称} | coding | 2 | #1 | L | {描述} |
| 4 | {名称} | test | 3 | #2,#3 | M | {描述} |

### 依赖图
{文字描述的 DAG}

### 并行度分析
- 最大并行数：{n}
- 关键路径：{task chain}
- 预计总阶段数：{n}

### 风险与 Gate
- {风险描述} → 建议设置 {gate_type} Gate
```

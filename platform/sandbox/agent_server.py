"""Lightweight agent server that runs inside sandbox containers.

Receives stage execution requests via HTTP, creates a SkillKit AgentRunner,
runs the full LLM chat loop with tools, and returns structured results.

Usage inside container:
    python agent_server.py --port 9090
"""
from __future__ import annotations

import asyncio
import json
import logging
import os
import sys
import time
from pathlib import Path
from typing import Any

from aiohttp import web

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(levelname)s %(name)s: %(message)s",
)
logger = logging.getLogger("sandbox-agent")

# SkillKit is installed inside the container image
try:
    from skillkit import AgentRunner
except ImportError:
    logger.error("SkillKit not available in container — cannot execute agent stages")
    sys.exit(1)


# ---------------------------------------------------------------------------
# Sandboxed runner with tool filtering (mirrors platform SandboxedAgentRunner)
# ---------------------------------------------------------------------------
_ALL_TOOLS = {"read", "write", "execute", "execute_script", "skill"}


class ContainerAgentRunner(AgentRunner):
    """AgentRunner with tool filtering and cwd injection, running inside the container."""

    def __init__(self, *args, default_cwd: str | None = None,
                 allowed_tools: set[str] | None = None, **kwargs):
        super().__init__(*args, **kwargs)
        self.default_cwd = default_cwd
        self.allowed_tools = allowed_tools or _ALL_TOOLS
        self.tool_calls_log: list[dict[str, Any]] = []

    def get_tools(self):
        tools = super().get_tools()
        return [t for t in tools if t["function"]["name"] in self.allowed_tools]

    async def _execute_tool(self, tool_call, on_output=None):
        name = tool_call.get("name", "")
        started = time.monotonic()

        # Inject default cwd for execution tools
        if self.default_cwd and name in ("execute", "execute_script"):
            args = json.loads(tool_call.get("arguments", "{}"))
            if not args.get("cwd"):
                args["cwd"] = self.default_cwd
                tool_call = {**tool_call, "arguments": json.dumps(args)}

        # Block disallowed tools
        if name not in self.allowed_tools:
            return f"Error: {name} is not allowed for this role"

        result = await super()._execute_tool(tool_call, on_output)

        elapsed_ms = round((time.monotonic() - started) * 1000, 2)
        args = json.loads(tool_call.get("arguments", "{}"))
        self.tool_calls_log.append({
            "tool_name": name,
            "args": args,
            "duration_ms": elapsed_ms,
            "result_preview": str(result)[:500] if result else "",
            "status": "failed" if str(result).startswith(("Error:", "Exit code:")) else "success",
        })

        return result


# ---------------------------------------------------------------------------
# Stage execution endpoint
# ---------------------------------------------------------------------------
async def handle_execute(request: web.Request) -> web.Response:
    """Execute a single agent stage.

    Expects JSON body:
    {
        "system_prompt": str,
        "user_prompt": str,
        "model": str | null,
        "max_turns": int,
        "enable_tools": bool,
        "allowed_tools": ["read", "write", "execute", ...],
        "skill_dirs": ["/skills/shared", "/skills/coding"],
        "workdir": "/workspace",
        "timeout": 300
    }

    Returns JSON:
    {
        "text_content": str,
        "total_tokens": int,
        "tool_calls": [...],
        "error": str | null
    }
    """
    try:
        body = await request.json()
    except json.JSONDecodeError:
        return web.json_response({"error": "Invalid JSON"}, status=400)

    system_prompt = body.get("system_prompt", "")
    user_prompt = body.get("user_prompt", "")
    model = body.get("model")
    max_turns = body.get("max_turns", 20)
    enable_tools = body.get("enable_tools", True)
    allowed_tools = set(body.get("allowed_tools", list(_ALL_TOOLS)))
    skill_dirs_raw = body.get("skill_dirs", [])
    workdir = body.get("workdir", "/workspace")
    timeout = body.get("timeout", 300)

    # Resolve skill directories (only include dirs that exist)
    skill_dirs = [Path(d) for d in skill_dirs_raw if Path(d).is_dir()]

    logger.info(
        "Executing stage: model=%s max_turns=%d tools=%s workdir=%s timeout=%ds",
        model or "default", max_turns, sorted(allowed_tools), workdir, timeout,
    )

    # Build AgentRunner
    create_kwargs: dict[str, Any] = dict(
        skill_dirs=skill_dirs,
        system_prompt=system_prompt,
        max_turns=max_turns,
        enable_tools=enable_tools,
        load_context_files=False,
    )
    if model:
        create_kwargs["model"] = model

    try:
        base = AgentRunner.create(**create_kwargs)
        runner = ContainerAgentRunner(
            engine=base.engine,
            config=base.config,
            default_cwd=workdir,
            allowed_tools=allowed_tools if enable_tools else set(),
        )
    except Exception as e:
        logger.exception("Failed to create AgentRunner")
        return web.json_response({
            "text_content": "",
            "total_tokens": 0,
            "tool_calls": [],
            "error": f"AgentRunner creation failed: {e}",
        }, status=500)

    # Run the chat loop with timeout
    try:
        response = await asyncio.wait_for(
            runner.chat(user_prompt, reset=True),
            timeout=timeout,
        )
        text_content = response.text_content or ""
        total_tokens = runner.cumulative_usage.total_tokens

        # Handle truncated output (max turns)
        _MAX_CONTINUATIONS = 3
        _SENTINEL = "Max turns reached"
        continuations = 0
        while _SENTINEL in text_content and continuations < _MAX_CONTINUATIONS:
            continuations += 1
            logger.info("Output truncated, sending continuation %d/%d", continuations, _MAX_CONTINUATIONS)
            try:
                cont = await asyncio.wait_for(
                    runner.chat("请继续完成上面的输出，从你停下的地方继续。", reset=False),
                    timeout=timeout,
                )
                cont_text = cont.text_content or ""
                text_content = text_content.replace(
                    f"[{_SENTINEL}. Please continue the conversation.]", "",
                ).strip()
                text_content = f"{text_content}\n\n{cont_text}".strip()
                total_tokens = runner.cumulative_usage.total_tokens
            except Exception as e:
                logger.warning("Continuation %d failed: %s", continuations, e)
                break

        logger.info("Stage completed: %d tokens, %d tool calls", total_tokens, len(runner.tool_calls_log))

        return web.json_response({
            "text_content": text_content,
            "total_tokens": total_tokens,
            "tool_calls": runner.tool_calls_log,
            "error": None,
        })

    except asyncio.TimeoutError:
        logger.error("Stage execution timed out after %ds", timeout)
        return web.json_response({
            "text_content": "",
            "total_tokens": runner.cumulative_usage.total_tokens if hasattr(runner, "cumulative_usage") else 0,
            "tool_calls": runner.tool_calls_log,
            "error": f"Stage timed out after {timeout}s",
        }, status=504)

    except Exception as e:
        logger.exception("Stage execution failed")
        return web.json_response({
            "text_content": "",
            "total_tokens": 0,
            "tool_calls": runner.tool_calls_log if hasattr(runner, "tool_calls_log") else [],
            "error": str(e),
        }, status=500)


async def handle_health(request: web.Request) -> web.Response:
    """Health check endpoint."""
    return web.json_response({"status": "ok", "agent": "sandbox"})


def create_app() -> web.Application:
    app = web.Application()
    app.router.add_post("/execute", handle_execute)
    app.router.add_get("/health", handle_health)
    return app


if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(description="Sandbox Agent Server")
    parser.add_argument("--port", type=int, default=int(os.environ.get("AGENT_PORT", "9090")))
    parser.add_argument("--host", default="0.0.0.0")
    args = parser.parse_args()

    logger.info("Starting sandbox agent server on %s:%d", args.host, args.port)
    web.run_app(create_app(), host=args.host, port=args.port)
